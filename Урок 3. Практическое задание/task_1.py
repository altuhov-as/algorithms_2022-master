"""
Задание 1.

Реализуйте:

a) заполнение списка, оцените сложность в O-нотации.
   заполнение словаря, оцените сложность в O-нотации.
   сделайте аналитику, что заполняется быстрее и почему.
   сделайте замеры времени.

b) выполните со списком и словарем операции: изменения и удаления элемента.
   оцените сложности в O-нотации для операций
   получения и удаления по списку и словарю
   сделайте аналитику, какие операции быстрее и почему
   сделайте замеры времени.


ВНИМАНИЕ: в задании два пункта - а) и b)
НУЖНО выполнить оба пункта

Подсказка: для замеров воспользуйтесь модулем time (см. примеры урока 1)
вы уже знаете, что такое декоратор и как его реализовать,
обязательно реализуйте ф-цию-декоратор и пусть она считает время
И примените ее к своим функциям!
"""
import random
import time


def time_of_function(function):
    def wrapper(*args):
        start_val = time.time()
        function(*args)
        end_val = time.time()
        time_funk = end_val - start_val
        return time_funk
    return wrapper


my_list = []
my_dict = {}


@time_of_function
def list_app(i=1):
    for i in range(i):
        my_list.append(random.choice(range(1000, 10000000000))) #O(1)


@time_of_function
def list_change(i=1):
    for i in range(i//1000):
        my_list[i] = 1                                         #O(1)


@time_of_function
def remove_in_list(i=1):
    for i in range(i//1000):
        del my_list[i]      #Удаление элемента (del) 	del l[i] 	O(N) 	Зависит от i. O(N) – в худшем случае


@time_of_function
def dict_app(i=1):
    for i in range(i):
        my_dict[i] = (random.choice(range(1000, 10000000000)))  #O(1)


@time_of_function
def dict_change(i=1):
    for i in range(i//1000):
        my_dict[i] = 1                                          #O(1)


@time_of_function
def remove_in_dict(i=1):
    for i in range(i//1000):
        del my_dict[i]                                       #Удаление элемента (del) 	del d[k] 	O(1)


print("Список заполняется быстрее" if list_app(100000) < dict_app(100000) else "Словарь заполняется быстрее")
"""Время выполнения добавления элементов в словарь больше, чем в список,
из-за расчёта хеша для эллементов. 
"""

print("Элементы списка изменяются быстрее" if list_change(100000) < dict_change(100000) else
      "Элементы словаря изменяются быстрее")
"""
Словарь выполняет математическую операцию над ключом быстрее, которая превращает его в значение,
которое является местом внутри словаря, которое является тем же местом, где оно было вставлено.
Словарь использует хэширование для поиска данных.
"""

print("Удаление элементов списка быстрее" if remove_in_list(100000) < remove_in_dict(100000) else
      "Удаление элементов словаря быстрее")
"""
Удаление элементов словаря быстрее
"""

print()
print(f"Время заполнение списка - словаря: {list_app(100000)} - {dict_app(100000)}")
print(f"Время изменения элементов списка - словаря: {list_change(100000)} - {dict_change(100000)}")
print(f"Время удаления элементов в списке - словаря: {remove_in_list(100000)} - {remove_in_dict(100000)}")
